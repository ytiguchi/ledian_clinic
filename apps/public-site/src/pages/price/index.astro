---
import PublicLayout from '../../layouts/PublicLayout.astro';
import '../../styles/price.css';

// D1からデータ取得
const db = Astro.locals.runtime.env.DB;

// カテゴリを取得
type Category = {
  id: string;
  name: string;
  slug: string;
};

// サブカテゴリを取得（施術グループ）
type Subcategory = {
  id: string;
  category_id: string;
  name: string;
  slug: string;
};

// 施術とプランを取得
type TreatmentPlan = {
  id: string;
  treatment_id: string;
  treatment_name: string;
  subcategory_id: string;
  subcategory_name: string;
  category_id: string;
  category_name: string;
  plan_name: string;
  sessions: number | null;
  quantity: string | null;
  price: number;
  price_taxed: number;
  notes: string | null;
};

let categories: Category[] = [];
let subcategories: Subcategory[] = [];
let plans: TreatmentPlan[] = [];

try {
  const catResult = await db.prepare(`
    SELECT id, name, slug
    FROM categories
    WHERE is_active = 1
    ORDER BY sort_order
  `).all();
  categories = catResult.results as Category[];

  const subcatResult = await db.prepare(`
    SELECT id, category_id, name, slug
    FROM subcategories
    WHERE is_active = 1
    ORDER BY sort_order
  `).all();
  subcategories = subcatResult.results as Subcategory[];
  
  const planResult = await db.prepare(`
    SELECT 
      tp.id,
      tp.treatment_id,
      t.name as treatment_name,
      sc.id as subcategory_id,
      sc.name as subcategory_name,
      c.id as category_id,
      c.name as category_name,
      tp.plan_name,
      tp.sessions,
      tp.quantity,
      tp.price,
      tp.price_taxed,
      tp.notes
    FROM treatment_plans tp
    JOIN treatments t ON tp.treatment_id = t.id
    JOIN subcategories sc ON t.subcategory_id = sc.id
    JOIN categories c ON sc.category_id = c.id
    WHERE tp.is_active = 1 AND t.is_active = 1 AND sc.is_active = 1 AND c.is_active = 1
    ORDER BY c.sort_order, sc.sort_order, t.sort_order, tp.sort_order
  `).all();
  plans = planResult.results as TreatmentPlan[];
} catch (e) {
  console.error('Failed to fetch data:', e);
}

// 施術ごとにグループ化
type TreatmentWithPlans = {
  id: string;
  name: string;
  subcategory_id: string;
  plans: TreatmentPlan[];
};

// 施術IDでユニークにグループ化
const treatmentMap = new Map<string, TreatmentWithPlans>();
plans.forEach(plan => {
  if (!treatmentMap.has(plan.treatment_id)) {
    treatmentMap.set(plan.treatment_id, {
      id: plan.treatment_id,
      name: plan.treatment_name,
      subcategory_id: plan.subcategory_id,
      plans: []
    });
  }
  treatmentMap.get(plan.treatment_id)?.plans.push(plan);
});

// サブカテゴリ→施術のマップを作成
type SubcategoryWithTreatments = {
  id: string;
  name: string;
  category_id: string;
  treatments: TreatmentWithPlans[];
};

const subcategoryMap = new Map<string, SubcategoryWithTreatments>();
subcategories.forEach(subcat => {
  subcategoryMap.set(subcat.id, {
    id: subcat.id,
    name: subcat.name,
    category_id: subcat.category_id,
    treatments: Array.from(treatmentMap.values()).filter(t => t.subcategory_id === subcat.id)
  });
});

// カテゴリ→サブカテゴリ→施術の3階層構造
type CategoryWithSubcategories = {
  id: string;
  name: string;
  subcategories: SubcategoryWithTreatments[];
};

const groupedData: CategoryWithSubcategories[] = categories.map(cat => ({
  id: cat.id,
  name: cat.name,
  subcategories: Array.from(subcategoryMap.values())
    .filter(sc => sc.category_id === cat.id && sc.treatments.length > 0)
})).filter(group => group.subcategories.length > 0);

function formatPrice(price: number): string {
  return new Intl.NumberFormat('ja-JP').format(price);
}

// アクティブなカテゴリー名リストを作成（ナビ用）
const activeCategories = groupedData.map(g => ({ id: g.id, name: g.name }));
---

<PublicLayout 
  title="料金表" 
  description="Ledian Clinicの料金表です。HIFU、ポテンツァ、ピーリング、ボトックスなど、各施術の料金一覧をご確認いただけます。"
>
  <!-- Breadcrumb -->
  <nav class="breadcrumb">
    <div class="container">
      <ol class="breadcrumb-list">
        <li><a href="/">ホーム</a></li>
        <li>料金表</li>
      </ol>
    </div>
  </nav>

  <!-- Page Header -->
  <section class="page-header">
    <div class="container">
      <h1 class="page-title">料金表</h1>
      <p class="page-title-en">PRICE</p>
    </div>
  </section>

  <!-- Category Navigation Grid -->
  <section class="category-nav-section">
    <div class="container">
      <nav class="category-nav-box">
        <ul class="category-nav-grid">
          {activeCategories.map((cat) => (
            <li>
              <a href={`#price-group-${cat.id}`} class="category-nav-btn">
                <span class="category-nav-text">{cat.name}</span>
                <img src="/images/icons/service-arrow-down.svg" alt="" class="category-nav-arrow" />
              </a>
            </li>
          ))}
        </ul>
      </nav>
      <p class="table-scroll-hint">料金表は横にスクロールできます</p>
    </div>
  </section>

  <!-- Price Groups by Category -->
  <section class="price-section">
    <div class="container">
      {groupedData.map((category) => (
        <div class="category-block" id={`price-group-${category.id}`}>
          <h2 class="category-title">
            <span class="category-title-bar"></span>
            {category.name}
          </h2>
          
          {category.subcategories.map((subcat) => {
            // subcategory内の全プランをフラットに収集
            const allPlans = subcat.treatments.flatMap(t => t.plans);
            const hasNotes = allPlans.some(p => p.notes);
            
            return (
              <div class="accordion-item" data-accordion>
                <button 
                  type="button" 
                  class="accordion-trigger"
                  aria-expanded="false"
                >
                  <span class="accordion-label">{subcat.name}</span>
                  <svg class="accordion-icon" width="12" height="12" viewBox="0 0 12 12" fill="none">
                    <path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <div class="accordion-content">
                  <div class="price-table-wrapper">
                    <table class="price-table">
                      <thead>
                        <tr>
                          <th class="col-name">項目名</th>
                          <th class="col-sessions">回数</th>
                          <th class="col-price">価格</th>
                          {hasNotes && (
                            <th class="col-desc">説明</th>
                          )}
                        </tr>
                      </thead>
                      <tbody>
                        {allPlans.map((plan, planIndex) => {
                          // 同じtreatment_nameの最初の行かどうか判定
                          const sameNamePlans = allPlans.filter(p => p.treatment_name === plan.treatment_name);
                          const isFirstOfGroup = planIndex === allPlans.findIndex(p => p.treatment_name === plan.treatment_name);
                          const rowSpan = sameNamePlans.length;
                          
                          // 表示用の項目名を生成（重複チェック付き）
                          let displayName = plan.treatment_name;
                          
                          // plan_nameを追加（重複していない場合のみ）
                          if (plan.plan_name && 
                              plan.plan_name !== plan.treatment_name && 
                              !plan.plan_name.match(/^\d+回$/) &&
                              !displayName.includes(plan.plan_name)) {
                            displayName = `${plan.treatment_name} ${plan.plan_name}`;
                          }
                          
                          // quantityを追加（treatment_nameに既に含まれていない場合のみ）
                          if (plan.quantity && !displayName.includes(plan.quantity)) {
                            displayName += ` ${plan.quantity}`;
                          }
                          
                          // 同じtreatment_nameでグループ化されている場合はrowspanを使う
                          const groupByTreatment = sameNamePlans.length > 1 && sameNamePlans.every(p => p.plan_name?.match(/^\d+回$/) || !p.plan_name);
                          
                          return (
                            <tr>
                              {groupByTreatment ? (
                                isFirstOfGroup && (
                                  <td class="col-name" rowspan={rowSpan}>{plan.treatment_name}</td>
                                )
                              ) : (
                                <td class="col-name">{displayName}</td>
                              )}
                              <td class="col-sessions">
                                {plan.sessions ? `${plan.sessions}回` : 
                                 plan.plan_name?.match(/^\d+回$/) ? plan.plan_name : 
                                 plan.quantity || '-'}
                              </td>
                              <td class="col-price">
                                <span class="price-main">{formatPrice(plan.price)}円</span>
                                <span class="price-tax">(税込{formatPrice(plan.price_taxed)}円)</span>
                              </td>
                              {hasNotes && (
                                groupByTreatment ? (
                                  isFirstOfGroup && (
                                    <td class="col-desc" rowspan={rowSpan}>{plan.notes || ''}</td>
                                  )
                                ) : (
                                  <td class="col-desc">{plan.notes || ''}</td>
                                )
                              )}
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      ))}

      {groupedData.length === 0 && (
        <div class="no-data">
          <p>料金情報を読み込み中...</p>
        </div>
      )}
    </div>
  </section>
</PublicLayout>



<script>
  // Accordion functionality
  document.querySelectorAll('[data-accordion]').forEach((item) => {
    const trigger = item.querySelector('.accordion-trigger');
    const content = item.querySelector('.accordion-content');
    
    trigger?.addEventListener('click', () => {
      const isExpanded = trigger.getAttribute('aria-expanded') === 'true';
      
      // Toggle current accordion
      trigger.setAttribute('aria-expanded', String(!isExpanded));
      content?.classList.toggle('active');
    });
  });
  
  // Smooth scroll for category navigation
  document.querySelectorAll('.category-nav-btn').forEach((link) => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const href = link.getAttribute('href');
      if (href) {
        const target = document.querySelector(href);
        if (target) {
          const headerOffset = 20;
          const elementPosition = target.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
          
          window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth'
          });
        }
      }
    });
  });
</script>
